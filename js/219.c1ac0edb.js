(window.webpackJsonp=window.webpackJsonp||[]).push([[219],{871:function(n,e){n.exports="### 23.Merge k Sorted Lists\n\nMerge k `sorted linked lists` and return it as `one sorted list`. Analyze and describe its complexity.\n\nExample:\n\n```js\nInput:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nOutput: 1->1->2->3->4->4->5->6\n```\n\n### Analyze\n\n思路一: 分治算法。可以将合并 k 个排序队列转换为合并 2 个排序队列。\n\n图例解释:\n\n```js\n   cur\ndummyNode -> 1 -> 4 -> 5\n\ncomparedCur\n    2       -> 6\n```\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n  let result = lists[0] || null\n\n  for (let i = 1; i < lists.length; i++) {\n    const compareList = lists[i]\n    result = mergeTwoLists(result, compareList)\n  }\n  return result\n}\n\nvar mergeTwoLists = function(curList, compareList) {\n  const dummyNode = new ListNode(0)\n  dummyNode.next = curList\n  let cur = dummyNode\n  let comparedCur = compareList\n\n  while (cur.next && comparedCur) {\n    if (cur.next.val > comparedCur.val) {\n      let nextComparedCur = comparedCur.next\n      comparedCur.next = cur.next\n      cur.next = comparedCur\n      comparedCur = nextComparedCur\n    }\n    cur = cur.next\n  }\n  if (comparedCur) {\n    cur.next = comparedCur\n  }\n\n  return dummyNode.next\n}\n```\n\n思路二: 优先队列\n\n* 将数组中的队列加入进优先队列(基于最小堆);\n* 如果当前优先队列不为空:\n  * 取出当前优先队列顶部队列元素(最小值), 拼接到输出队列中;\n  * 同时在优先队列插入取出的顶部队列元素的下一个值;\n\n由于在 JavaScrit 中没有封装好的优先队列, 在此先进行封装`优先队列函数`(最小堆)。\n\n\n\n```js\nInput:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nOutput: 1->1->2->3->4->4->5->6\n```\n\n"}}]);
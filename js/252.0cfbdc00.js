(window.webpackJsonp=window.webpackJsonp||[]).push([[252],{907:function(n,r){n.exports="### title\n\n给定一个可包含重复数字的序列, 返回所有不重复的全排列。\n\n示例:\n\n```\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n### analyze\n\n[题目 46](https://github.com/MuYunyun/blog/blob/master/LeetCode/46.全排列/README.md) 的升级版\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function (nums) {\n  const result = []\n  const sortNum = nums.sort()\n  const used = new Array(nums.length).fill(false)\n  const DFS = function (arr) {\n    if (arr.length === sortNum.length) {\n      result.push(arr.slice())\n      return\n    }\n\n    for (let i = 0; i < sortNum.length; i++) {\n      if (i > 0 && sortNum[i] === sortNum[i - 1] && !used[i - 1]) { // !used[i - 1] 表示相同的元素之前已经使用过了\n        continue\n      }\n\n      if (!used[i]) {\n        arr.push(sortNum[i])\n        used[i] = true\n        DFS(arr)\n        arr.pop(sortNum[i])\n        used[i] = false\n      }\n    }\n  }\n\n  DFS([])\n\n  return result\n};\n```"}}]);